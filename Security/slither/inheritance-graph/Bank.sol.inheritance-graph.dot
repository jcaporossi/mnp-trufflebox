digraph "" {
VRFConsumerBase -> VRFRequestIDBase;
VRFConsumerBase[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>VRFConsumerBase</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    rawFulfillRandomness(bytes32,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    fulfillRandomness(bytes32,uint256)</TD></TR><TR><TD align="left">    requestRandomness(bytes32,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    USER_SEED_PLACEHOLDER</TD></TR><TR><TD align="left">    LINK<font color="blue" POINT-SIZE="10"> (LinkTokenInterface)</font></TD></TR><TR><TD align="left">    vrfCoordinator</TD></TR><TR><TD align="left">    nonces</TD></TR></TABLE> >];

VRFRequestIDBase[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>VRFRequestIDBase</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    makeVRFInputSeed(bytes32,uint256,address,uint256)</TD></TR><TR><TD align="left">    makeRequestId(bytes32,uint256)</TD></TR></TABLE> >];

AggregatorV3Interface[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AggregatorV3Interface</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    decimals()</TD></TR><TR><TD align="left">    description()</TD></TR><TR><TD align="left">    version()</TD></TR><TR><TD align="left">    getRoundData(uint80)</TD></TR><TR><TD align="left">    latestRoundData()</TD></TR></TABLE> >];

LinkTokenInterface[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LinkTokenInterface</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    allowance(address,address)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    decimals()</TD></TR><TR><TD align="left">    decreaseApproval(address,uint256)</TD></TR><TR><TD align="left">    increaseApproval(address,uint256)</TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    transfer(address,uint256)</TD></TR><TR><TD align="left">    transferAndCall(address,uint256,bytes)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR></TABLE> >];

AccessControl -> Context [ label="1" ];
AccessControl -> IAccessControl [ label="2" ];
AccessControl -> ERC165 [ label="3" ];
AccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleAdmin(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    renounceRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkRole(bytes32,address)</TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

IAccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR></TABLE> >];

Ownable -> Context;
Ownable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Ownable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transferOwnership(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

IERC2981 -> IERC165;
IERC2981[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC2981</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    royaltyInfo(uint256,uint256)</TD></TR></TABLE> >];

Pausable -> Context;
Pausable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Pausable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    paused()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _pause()</TD></TR><TR><TD align="left">    _unpause()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    whenNotPaused()</TD></TR><TR><TD align="left">    whenPaused()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _paused</TD></TR></TABLE> >];

ERC20 -> Context [ label="1" ];
ERC20 -> IERC20 [ label="2" ];
ERC20 -> IERC20Metadata [ label="3" ];
ERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transfer(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    allowance(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left">    increaseAllowance(address,uint256)</TD></TR><TR><TD align="left">    decreaseAllowance(address,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(address,uint256)</TD></TR><TR><TD align="left">    _approve(address,address,uint256)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _allowances</TD></TR><TR><TD align="left">    _totalSupply</TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR></TABLE> >];

IERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    transfer(address,uint256)</TD></TR><TR><TD align="left">    allowance(address,address)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR></TABLE> >];

ERC20Burnable -> Context [ label="1" ];
ERC20Burnable -> ERC20 [ label="2" ];
ERC20Burnable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Burnable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(uint256)</TD></TR><TR><TD align="left">    burnFrom(address,uint256)</TD></TR></TABLE> >];

ERC20Capped -> ERC20;
ERC20Capped[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Capped</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    cap()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _mint(address,uint256)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _cap</TD></TR></TABLE> >];

ERC20Pausable -> ERC20 [ label="1" ];
ERC20Pausable -> Pausable [ label="2" ];
ERC20Pausable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Pausable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256)</font></TD></TR></TABLE> >];

IERC20Metadata -> IERC20;
IERC20Metadata[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20Metadata</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    decimals()</TD></TR></TABLE> >];

ERC721 -> Context [ label="1" ];
ERC721 -> ERC165 [ label="2" ];
ERC721 -> IERC721 [ label="3" ];
ERC721 -> IERC721Metadata [ label="4" ];
ERC721[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    ownerOf(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenURI(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getApproved(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _baseURI()</TD></TR><TR><TD align="left">    _safeTransfer(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    _exists(uint256)</TD></TR><TR><TD align="left">    _isApprovedOrOwner(address,uint256)</TD></TR><TR><TD align="left">    _safeMint(address,uint256)</TD></TR><TR><TD align="left">    _safeMint(address,uint256,bytes)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(uint256)</TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _approve(address,uint256)</TD></TR><TR><TD align="left">    _setApprovalForAll(address,address,bool)</TD></TR><TR><TD align="left">    _checkOnERC721Received(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR><TR><TD align="left">    _owners</TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _tokenApprovals</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR></TABLE> >];

IERC721 -> IERC165;
IERC721[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    ownerOf(uint256)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    getApproved(uint256)</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,bytes)</TD></TR></TABLE> >];

IERC721Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC721Received(address,address,uint256,bytes)</TD></TR></TABLE> >];

ERC721Enumerable -> ERC721 [ label="1" ];
ERC721Enumerable -> IERC721Enumerable [ label="2" ];
ERC721Enumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721Enumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenOfOwnerByIndex(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenByIndex(uint256)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256)</font></TD></TR><TR><TD align="left">    _addTokenToOwnerEnumeration(address,uint256)</TD></TR><TR><TD align="left">    _addTokenToAllTokensEnumeration(uint256)</TD></TR><TR><TD align="left">    _removeTokenFromOwnerEnumeration(address,uint256)</TD></TR><TR><TD align="left">    _removeTokenFromAllTokensEnumeration(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _ownedTokens</TD></TR><TR><TD align="left">    _ownedTokensIndex</TD></TR><TR><TD align="left">    _allTokens</TD></TR><TR><TD align="left">    _allTokensIndex</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'balanceOf(address)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.<BR/>'ownerOf(uint256)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.<BR/>'safeTransferFrom(address,address,uint256)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.<BR/>'transferFrom(address,address,uint256)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.<BR/>'approve(address,uint256)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.<BR/>'getApproved(uint256)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.<BR/>'setApprovalForAll(address,bool)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.<BR/>'isApprovedForAll(address,address)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.<BR/>'safeTransferFrom(address,address,uint256,bytes)' collides in inherited contracts IERC721, ERC721 where ERC721 is chosen.</font></TD></TR></TABLE> >];

IERC721Enumerable -> IERC721;
IERC721Enumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Enumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    tokenOfOwnerByIndex(address,uint256)</TD></TR><TR><TD align="left">    tokenByIndex(uint256)</TD></TR></TABLE> >];

IERC721Metadata -> IERC721;
IERC721Metadata[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Metadata</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    tokenURI(uint256)</TD></TR></TABLE> >];

Address[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Address</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResult(bool,bytes,string)</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

Strings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Strings</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _HEX_SYMBOLS</TD></TR></TABLE> >];

ERC165 -> IERC165;
ERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR></TABLE> >];

IERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

BankContract -> AccessControl [ label="1" ];
BankContract -> IERC721Receiver [ label="2" ];
BankContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BankContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    buyPawn()</TD></TR><TR><TD align="left">    locatePlayer(uint16)</TD></TR><TR><TD align="left">    enrollPlayer(uint16)</TD></TR><TR><TD align="left">    rollDices(uint16)</TD></TR><TR><TD align="left">    buyMono()</TD></TR><TR><TD align="left">    buyProp(uint16)</TD></TR><TR><TD align="left">    payRent(uint16)</TD></TR><TR><TD align="left">    payCommunityTax(uint16)</TD></TR><TR><TD align="left">    receiveChanceProfit(uint16)</TD></TR><TR><TD align="left">    getPriceOfProp(uint16,uint8,uint8)</TD></TR><TR><TD align="left">    setPriceOfProp(uint16,uint8,uint8,uint256)</TD></TR><TR><TD align="left">    withdraw(address,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC721Received(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left">    setPrices(uint16,uint8,uint8,uint16,uint256[])</TD></TR><TR><TD align="left">    propertyTransfer(address,address,uint256,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    retrievePropertyRent(uint16,uint8,uint8)</TD></TR><TR><TD align="left">    retrieveChanceProfit(uint256)</TD></TR><TR><TD align="left">    retrieveCommunityTax(uint256)</TD></TR><TR><TD align="left">    retrievePropertyRarity(uint256)</TD></TR><TR><TD align="left">    calculateRandomInteger(string,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    ADMIN_ROLE</TD></TR><TR><TD align="left">    BANKER_ROLE</TD></TR><TR><TD align="left">    enroll_fee</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    Pawn<font color="blue" POINT-SIZE="10"> (PawnContract)</font></TD></TR><TR><TD align="left">    Board<font color="blue" POINT-SIZE="10"> (BoardContract)</font></TD></TR><TR><TD align="left">    Prop<font color="blue" POINT-SIZE="10"> (PropContract)</font></TD></TR><TR><TD align="left">    Mono<font color="blue" POINT-SIZE="10"> (MonoContract)</font></TD></TR><TR><TD align="left">    Link<font color="blue" POINT-SIZE="10"> (IERC20)</font></TD></TR><TR><TD align="left">    Staking<font color="blue" POINT-SIZE="10"> (StakingContract)</font></TD></TR><TR><TD align="left">    propPrices</TD></TR></TABLE> >];

BoardContract -> AccessControl [ label="1" ];
BoardContract -> VRFConsumerBase [ label="2" ];
BoardContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BoardContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    isPurchasable(uint16,uint8)</TD></TR><TR><TD align="left">    getMaxEdition()</TD></TR><TR><TD align="left">    getNbLands(uint16)</TD></TR><TR><TD align="left">    getRarityLevel(uint16)</TD></TR><TR><TD align="left">    newBoard(uint8,uint8,uint8[],uint16)</TD></TR><TR><TD align="left">    register(uint16,uint256)</TD></TR><TR><TD align="left">    isRegistered(uint16,uint256)</TD></TR><TR><TD align="left">    play(uint16,uint256)</TD></TR><TR><TD align="left">    getPawnInfo(uint16,uint256)</TD></TR><TR><TD align="left">    setPawnInfo(uint16,uint256,BoardContract.PawnInfo)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    requestRandomNumber()</TD></TR><TR><TD align="left"><font color="#FFA500">    fulfillRandomness(bytes32,uint256)</font></TD></TR><TR><TD align="left">    gameStrategist(uint16,uint256,uint8)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    ADMIN_ROLE</TD></TR><TR><TD align="left">    MANAGER_ROLE</TD></TR><TR><TD align="left">    fee</TD></TR><TR><TD align="left">    randomResult</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    keyHash</TD></TR><TR><TD align="left">    editionMax</TD></TR><TR><TD align="left">    boards</TD></TR><TR><TD align="left">    playInfoByRequestId</TD></TR></TABLE> >];

MonoContract -> ERC20Capped [ label="1" ];
MonoContract -> ERC20Burnable [ label="2" ];
MonoContract -> ERC20Pausable [ label="3" ];
MonoContract -> AccessControl [ label="4" ];
MonoContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MonoContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    mint(address,uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _mint(address,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    ADMIN_ROLE</TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR></TABLE> >];

PawnContract -> ERC721Enumerable [ label="1" ];
PawnContract -> AccessControl [ label="2" ];
PawnContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>PawnContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenURI(uint256)</font></TD></TR><TR><TD align="left">    mint(address)</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left">    get(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _baseURI()</font></TD></TR><TR><TD align="left">    generateID(PawnContract.PawnInfo)</TD></TR><TR><TD align="left">    random(address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    ADMIN_ROLE</TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    baseTokenURI</TD></TR><TR><TD align="left">    pawns</TD></TR></TABLE> >];

PropContract -> ERC721Enumerable [ label="1" ];
PropContract -> AccessControl [ label="2" ];
PropContract -> Ownable [ label="3" ];
PropContract -> IERC2981 [ label="4" ];
PropContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>PropContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    isValidProp(uint16,uint8,uint8)</TD></TR><TR><TD align="left"><font color="#FFA500">    tokenURI(uint256)</font></TD></TR><TR><TD align="left">    mint(address,uint16,uint8,uint8)</TD></TR><TR><TD align="left">    get(uint256)</TD></TR><TR><TD align="left">    exists(uint256)</TD></TR><TR><TD align="left">    getNbOfProps(uint16,uint8,uint8)</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left">    setDefaultRoyaltyPercentageBasisPoints(uint96)</TD></TR><TR><TD align="left">    setRoyalties(uint256,uint96)</TD></TR><TR><TD align="left"><font color="#FFA500">    royaltyInfo(uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left">    setIsOperatorAllowed(address,bool)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _baseURI()</font></TD></TR><TR><TD align="left">    generateID(uint16,uint8,uint8)</TD></TR><TR><TD align="left">    _setRoyalties(uint256)</TD></TR><TR><TD align="left">    _setRoyalties(uint256,uint96)</TD></TR><TR><TD align="left"><font color="#FFA500">    _isApprovedOrOwner(address,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    ADMIN_ROLE</TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left">    isOperatorAllowed</TD></TR><TR><TD align="left">    defaultRoyaltyPercentageBasisPoints</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _INTERFACE_ID_ERC2981</TD></TR><TR><TD align="left">    Board<font color="blue" POINT-SIZE="10"> (BoardContract)</font></TD></TR><TR><TD align="left">    props</TD></TR><TR><TD align="left">    numOfProps</TD></TR><TR><TD align="left">    royaltiesValuesByTokenId</TD></TR><TR><TD align="left">    baseTokenURI</TD></TR></TABLE> >];

StakingContract -> Ownable;
StakingContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>StakingContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getPools()</TD></TR><TR><TD align="left">    getUserBalanceInPool(address,address)</TD></TR><TR><TD align="left">    getPoolBalance(address)</TD></TR><TR><TD align="left">    addPool(address,address,uint256)</TD></TR><TR><TD align="left">    stake(address,uint256)</TD></TR><TR><TD align="left">    unstake(address)</TD></TR><TR><TD align="left">    pendingReward(address)</TD></TR><TR><TD align="left">    getLastPrice(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _addPool(address,address,uint256)</TD></TR><TR><TD align="left">    _calculateReward(address,StakingContract.PoolInfo,StakingContract.UserInfo)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    NETWORK_TOKEN_VIRTUAL_ADDRESS</TD></TR><TR><TD align="left">    networkTokenSymbol</TD></TR><TR><TD align="left">    rewardToken<font color="blue" POINT-SIZE="10"> (IERC20)</font></TD></TR><TR><TD align="left">    pools</TD></TR><TR><TD align="left">    poolAddressBySymbol</TD></TR><TR><TD align="left">    networkTokenPoolBalance</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    registeredPools</TD></TR></TABLE> >];

}