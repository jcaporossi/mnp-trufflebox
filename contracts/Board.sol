// Board.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

/// @title Board
/// @author Jerome Caporossi, StÃ©phane Chaunard, Alexandre Gautier
/// @notice Implements game logic and board's features
contract BoardContract is AccessControl, VRFConsumerBase {
	/// @dev structure used to store pawn's attribute
	struct PawnInfo {
		bool isOnBoard;
		uint8 position;
		bool rollingState;
		bytes32 requestId;
	}

	/// @dev structure used to store pawn's attribute
	struct BoardInfo {
		uint8 nbOfLands;
		uint8 rarityLevel;
		mapping(uint8 => bool) isBuildingLand;
		uint8 buildType;
		mapping(uint256 => PawnInfo) pawns;
		uint16 nb_pawns_max;
		uint16 nb_pawns;
	}

	/// @dev structure used to store pawn's attribute
	struct RandomInfo {
		uint16 edition;
		uint256 pawnId;
		uint256 randomness;
		uint256 blockNumber;
	}

	bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
	bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
	bytes32 internal keyHash;
	/// @dev number of board editions
	uint16 private editionMax;
	uint256 public fee;

	/// @dev store all boards by edition number
	mapping(uint16 => BoardInfo) private boards;
	mapping(bytes32 => RandomInfo) private randomInfoByRequestId;

	/// @notice event emitted when a new board is created
	/// @param new_edition_nb new board edition number
	event eBoard(uint16 indexed new_edition_nb);

	/// @notice event emitted when a new pawn is registered on a board
	/// @param _edition board edition number
	/// @param _pawnID pawn's ID
	event ePawn(uint16 indexed _edition, uint256 indexed _pawnID);

	event RandomNumberRequested (address player, bytes32 requestId);
	event RandomReady (bytes32 requestId);

	/// @notice constructor
	constructor(
		address _VRFCoordinator,
		address _LinkToken,
		bytes32 _keyHash,
		uint256 _Chainlinkfee
	) VRFConsumerBase(_VRFCoordinator, _LinkToken) {
		keyHash = _keyHash;
		fee = _Chainlinkfee;

		_setupRole(ADMIN_ROLE, msg.sender);
		_setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
		_setupRole(MANAGER_ROLE, msg.sender);
		_setRoleAdmin(MANAGER_ROLE, ADMIN_ROLE);

		editionMax = 0;

		BoardInfo storage b = boards[0];

		b.nbOfLands = 40;
		b.nb_pawns_max = 1000;
		b.rarityLevel = 2;
		b.isBuildingLand[1] = true;
		b.isBuildingLand[3] = true;
		b.isBuildingLand[5] = true;
		b.isBuildingLand[6] = true;
		b.isBuildingLand[8] = true;
		b.isBuildingLand[9] = true;
		b.isBuildingLand[11] = true;
		b.isBuildingLand[13] = true;
		b.isBuildingLand[14] = true;
		b.isBuildingLand[15] = true;
		b.isBuildingLand[16] = true;
		b.isBuildingLand[18] = true;
		b.isBuildingLand[19] = true;
		b.isBuildingLand[21] = true;
		b.isBuildingLand[23] = true;
		b.isBuildingLand[24] = true;
		b.isBuildingLand[25] = true;
		b.isBuildingLand[26] = true;
		b.isBuildingLand[27] = true;
		b.isBuildingLand[29] = true;
		b.isBuildingLand[31] = true;
		b.isBuildingLand[32] = true;
		b.isBuildingLand[34] = true;
		b.isBuildingLand[35] = true;
		b.isBuildingLand[37] = true;
		b.isBuildingLand[39] = true;

		b.buildType = 1;
	}


	/**
	 * @dev pseudo-random function to simulate the roll of dice in the game
	 * @return a random value in between [0, type(uint16).max]
	 */

	function getRandomKeccak256() public view returns (uint16) {
		return

			uint16(
				((uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, msg.sender))) %
					type(uint16).max) % 6) + 1
			);

	}

	/**
	 * @notice Requests randomness
	 */
	function requestRandomNumber(uint16 _edition, uint256 _pawnID) public {
		require(isRegistered(_edition, _pawnID), "pawn has not been registered");
		require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
		boards[_edition].pawns[_pawnID].rollingState = true;

		bytes32 _requestId = requestRandomness(keyHash, fee);
		randomInfoByRequestId[_requestId].edition = _edition;
		randomInfoByRequestId[_requestId].pawnId = _pawnID;
		boards[_edition].pawns[_pawnID].requestId = _requestId;

		emit RandomNumberRequested(msg.sender, _requestId);
	}

	function getRollingState(uint16 _edition, uint256 _pawnID) public view returns (bool){
		return boards[_edition].pawns[_pawnID].rollingState;
	}

	/**
	 * @notice get numbers generated by Chainlink VRF
	 * @return randomNumbers array of random numbers
	 */
	function getRandomNumbers(uint16 _edition, uint256 _pawnID) public view returns (uint8[4] memory randomNumbers){
		// Require pawn owner is the sender
		require(isRegistered(_edition, _pawnID),'pawn has not been registered');
		//boards[_edition].pawns[_pawnID].rollingState = false; //todo impossible with view
		bytes32 _requestId = boards[_edition].pawns[_pawnID].requestId;
		uint256 randomness = randomInfoByRequestId[_requestId].randomness;
		require(randomness != 0,'randomness is not prepared');

		// /!\ Don't forgot to change the range of array !!!
		uint8[4] memory randomNumbers;
		uint8 maxDices = 2;
		for (uint8 n = 0; n < maxDices; n++) {
			randomNumbers[n] = uint8((uint256(keccak256(abi.encode(randomness, n))) % 6) + 1);
		}

		// Extra random numbers
		uint8 maxExtraRandomNumbers = 2;
		for (uint8 n = 0; n < maxExtraRandomNumbers; n++) {
			randomNumbers[maxDices + n] = uint8(uint256(keccak256(abi.encode(randomness, maxDices + n))));
		}

		return randomNumbers;
	}
	
	/**
	 * @notice Callback function used by VRF Coordinator
	 * @param requestId the id of the request for the oracle
	 * @param randomness randomness must be requested from an oracle, which generates a number and a cryptographic proof
	 * @dev /!\ Maximum Gas for Callback : If your fulfillRandomness function uses more than 200k gas, the transaction will fail.
	 */
	function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
		randomInfoByRequestId[requestId].randomness = randomness;
		// todo record position NOW
		// todo Must call method HERE to calculate result NOW, we can't waiting for security reasons.
		// ex. throw tax payment if player's pawn is in a tax land now.
		emit RandomReady(requestId); // Throw dices in front
	}

	/**
	 * @notice check if a land can be built (PROP and BUILD tokens available)
	 * @param edition board edition
	 * @param land cell number
	 * @return true or false
	 */
	function isBuildingLand(uint16 edition, uint8 land) external view returns (bool) {
		return boards[edition].isBuildingLand[land];
	}

	/**
	 * @notice get the number of board editions
	 * @return number of board editions
	 */
	function getMaxEdition() external view returns (uint16) {
		return editionMax;
	}

	/**
	 * @notice get the number of lands for a board edition
	 * @param edition board edition
	 * @return number of lands
	 */
	function getNbLands(uint16 edition) external view returns (uint8) {
		return boards[edition].nbOfLands;
	}

	/**
	 * @notice get the number of rarity level for a board edition
	 * @param edition board edition
	 * @return number of rarity levels
	 */
	function getRarityLevel(uint16 edition) external view returns (uint8) {
		return boards[edition].rarityLevel;
	}

	/**
	 * @notice get the number of build types for a board edition
	 * @param edition board edition
	 * @return number of build types
	 */
	function getBuildType(uint16 edition) external view returns (uint8) {
		return boards[edition].buildType;
	}

	/**
	 * @notice create a new board
	 * @param _nbOfLands number of lands
	 * @param _rarityLevel number of rarity levels
	 * @param _buildingLands array of index of lands which can be built
	 * @param _buildType number of built types
	 * @param _maxPawns max number of pawns allowed
	 */
	function newBoard(
		uint8 _nbOfLands,
		uint8 _rarityLevel,
		uint8[] calldata _buildingLands,
		uint8 _buildType,
		uint16 _maxPawns
	) public onlyRole(MANAGER_ROLE) {
		editionMax += 1;
		BoardInfo storage b = boards[editionMax];
		b.nbOfLands = _nbOfLands;
		b.rarityLevel = _rarityLevel;
		for (uint8 i = 0; i < _buildingLands.length; i++) {
			require(_buildingLands[i] < b.nbOfLands, "land index out of range");
			b.isBuildingLand[_buildingLands[i]] = true;
		}

		b.buildType = _buildType;
		b.nb_pawns_max = _maxPawns;

		emit eBoard(editionMax);
	}

	/**
	 * @notice register a pawn on a board
	 * @param _edition board edition
	 * @param _pawnID pawn ID
	 */
	function register(uint16 _edition, uint256 _pawnID) external onlyRole(MANAGER_ROLE) returns (bool isOnBoarded) {
		require(_edition <= editionMax, "Unknown edition");
		require(boards[_edition].pawns[_pawnID].isOnBoard == false, "pawn already registered");
		require(boards[_edition].nb_pawns < boards[_edition].nb_pawns_max, "game is full");

		boards[_edition].pawns[_pawnID].isOnBoard = true;
		boards[_edition].nb_pawns += 1;

		emit ePawn(_edition, _pawnID);

		return true;
	}

	/**
	 * @notice check if a pawn is registered
	 * @param _edition board edition
	 * @param _pawnID pawn ID
	 * @return true or false
	 */
	function isRegistered(uint16 _edition, uint256 _pawnID) public view returns (bool) {
		return boards[_edition].pawns[_pawnID].isOnBoard;
	}

	/**
	 * @notice play with a pawn
	 * @param _edition board edition
	 * @param _pawnID pawn ID
	 * @return dices_score_ score of dices roll
	 */
	function play(uint16 _edition, uint256 _pawnID) external onlyRole(MANAGER_ROLE) returns (uint8 dices_score_) {
		require(boards[_edition].pawns[_pawnID].isOnBoard == true, "Unregistered pawn");

		// roll dices (randomly)
		dices_score_ = 4;
		//dices_score_ = getRandomNumber();

		// update player's position (modulo boards[edition].nbOfLands)
		boards[_edition].pawns[_pawnID].position += dices_score_ % boards[_edition].nbOfLands;

		//event new Position of pawn
	}

	/**
	 * @notice get position of a Pawn on a board
	 * @param _edition board edition
	 * @param _pawnID pawn ID
	 * @return index of land
	 */
	function getPawn(uint16 _edition, uint256 _pawnID) external view returns (uint8) {
		require(isRegistered(_edition, _pawnID), "pawn has not been regsitered");
		return boards[_edition].pawns[_pawnID].position;
	}
}
